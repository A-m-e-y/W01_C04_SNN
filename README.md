# Introduction

This project replicates the Johns Hopkins paper: 
"Designing Silicon Brains using LLM: Leveraging ChatGPT for Automated Description of a Spiking Neuron Array"
The goal is to implements a synthesizable System Verilog code for a programmable Spiking Neuron Array ASIC.

## Differences between Johns Hopkins paper implementation and this project:
- Instead of using ***ChatGPT4***, this project uses ***Claude 3.5 Sonnet***.
- Instead of writing the code in `Verilog`, this project uses `System Verilog`
- In the v2, instead of using a `LIF neuron`, this project tries to implement this using `RLU`.

## Design Process Followed -
### 1. First we will try to design the LIF Neuron Module (`claude_lif_neuron_v1.sv`)
   - Input Prompt Given to Claude:
   ```bash
   Can you write a synthesizable System Verilog module for a spiking leaky integrate and fire neuron? Please include a multibit current input and a refactory period.

   Also double and tripple check for errors before writing anything. Remember, my goal is to synthesize this code in to a netlist using Icarius Verilog.

   Write this code in a file called "claude_lif_neuron_v1.sv"
   ```
   - Output Code generated by Claude:
   <details>
      <summary>Click to expand code</summary>

   ```Verilog
      module claude_lif_neuron_v1 #(
          parameter INPUT_WIDTH = 8,              // Width of input current
          parameter POTENTIAL_WIDTH = 16,         // Width of membrane potential
          parameter THRESHOLD = 16'h7000,         // Firing threshold
          parameter LEAK_FACTOR = 4,             // Leak rate (power of 2 for division)
          parameter REFRACTORY_PERIOD = 4         // Number of cycles to wait after spike
      )(
          input  logic clk,                      // Clock input
          input  logic rst_n,                    // Active-low reset
          input  logic signed [INPUT_WIDTH-1:0] current_in,  // Input current
          output logic spike_out                 // Output spike
      );
      
          // Internal registers
          logic signed [POTENTIAL_WIDTH-1:0] membrane_potential;
          logic [$clog2(REFRACTORY_PERIOD)-1:0] refractory_counter;
          logic in_refractory;
      
          // Determine if in refractory period
          assign in_refractory = (refractory_counter != 0);
      
          // Main sequential logic
          always_ff @(posedge clk or negedge rst_n) begin
              if (!rst_n) begin
                  membrane_potential <= '0;
                  refractory_counter <= '0;
                  spike_out <= 1'b0;
              end else begin
                  // Handle spike output and refractory period
                  if (membrane_potential >= THRESHOLD && !in_refractory) begin
                      spike_out <= 1'b1;
                      membrane_potential <= '0;
                      refractory_counter <= REFRACTORY_PERIOD;
                  end else begin
                      spike_out <= 1'b0;
                      
                      // Update refractory counter
                      if (in_refractory) begin
                          refractory_counter <= refractory_counter - 1;
                      end
      
                      // Update membrane potential if not in refractory period
                      if (!in_refractory) begin
                          // Add input current and apply leak
                          membrane_potential <= membrane_potential + 
                                             {{(POTENTIAL_WIDTH-INPUT_WIDTH){current_in[INPUT_WIDTH-1]}}, current_in} - 
                                             (membrane_potential >>> LEAK_FACTOR);
                      end
                  end
              end
          end
      
      endmodule

   ```
   </details>
   
### 2. Extensive Testing to make sure there are no errors in the generated code:
      - We ask Claude to genaret a testbench in SV which has detailed testing inputs to test the DUT.
      - We can then run this TB using `iverilog` to check the output and identify bugs.

      ```Bash
      iverilog -g2005-sv tb_claude_lif_neuron_v1.sv claude_lif_neuron_v1.sv
      vvp a.out
      ```
### 3. Errors Found in the code:
   - Error 1:
      - `member_potential` is of `signed logic` data type
      - `THRESHOLD` is declared as a `paremeter` and parameters are by default `unsigned`
      - So when comparison happens, `signed logic member_potential` SystemVerilog will implicitly cast the signed operand to unsigned.
      - A signed number is represented in two's complement format. When cast to unsigned, the bit pattern remains the same, but its interpretation changes.
      - This will result in incorrect comparison for negative numbers.
      ```Verilog
      parameter THRESHOLD = 16'h7000,         // Firing threshold
      logic signed [POTENTIAL_WIDTH-1:0] membrane_potential;
      if (membrane_potential >= THRESHOLD && !in_refractory) begin
      ```
      - We can see this in the simulation results generated by the Testbench `tb_claude_lif_neuron_v1.sv`.
      - TB Output:
      ```Bash
      === LIF Neuron Testbench Started ===
      Threshold: 28672
      Leak Factor:           4
      Refractory Period:           4

      Time=480: current= -61, potential=     0, spike=1
      WARNING: Potential overflow detected at time 485!
      ```
   - Error 2:
      - The if statement for exceeding the threshold doesnt account for overflow.
   - Error 3:
      - Immediately after reset sequence, we see overflow in `membrane_potential` because it is being reset to 0.
      ```Bash
      WARNING: Potential overflow detected at time 5!
      ```
      
### 4. Fixed Output Code generated by Claude:
   <details>
      <summary>Click to expand code</summary>

   ```Verilog
module claude_lif_neuron_v1 #(
    parameter INPUT_WIDTH = 8,              // Width of input current
    parameter POTENTIAL_WIDTH = 16,         // Width of membrane potential
    parameter signed THRESHOLD = 16'sh7000,  // Firing threshold (now signed)
    parameter LEAK_FACTOR = 4,             // Leak rate (power of 2 for division)
    parameter REFRACTORY_PERIOD = 4         // Number of cycles to wait after spike
)(
    input  logic clk,                      // Clock input
    input  logic rst_n,                    // Active-low reset
    input  logic signed [INPUT_WIDTH-1:0] current_in,  // Input current
    output logic spike_out                 // Output spike
);

    // Internal registers
    logic signed [POTENTIAL_WIDTH-1:0] membrane_potential;
    logic [$clog2(REFRACTORY_PERIOD)-1:0] refractory_counter;
    logic in_refractory;
    
    // Move these declarations to module level for testbench visibility
    logic signed [POTENTIAL_WIDTH-1:0] extended_current;
    logic signed [POTENTIAL_WIDTH-1:0] leak_term;

    // Determine if in refractory period
    assign in_refractory = (refractory_counter != 0);

    // Main sequential logic
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            membrane_potential <= '0;
            refractory_counter <= '0;
            spike_out <= 1'b0;
        end else begin
            // Handle spike output and refractory period
            if (!in_refractory && 
                membrane_potential >= THRESHOLD && 
                membrane_potential < {1'b0, {(POTENTIAL_WIDTH-1){1'b1}}}) begin  // Check for positive value below max
                spike_out <= 1'b1;
                membrane_potential <= '0;
                refractory_counter <= REFRACTORY_PERIOD;
            end else begin
                spike_out <= 1'b0;
                
                // Update refractory counter
                if (in_refractory) begin
                    refractory_counter <= refractory_counter - 1;
                end

                // Update membrane potential if not in refractory period
                if (!in_refractory) begin
                    // Sign extend the input current
                    extended_current = {{(POTENTIAL_WIDTH-INPUT_WIDTH){current_in[INPUT_WIDTH-1]}}, current_in};
                    
                    // Calculate leak term (ensure sign is preserved)
                    leak_term = membrane_potential >>> LEAK_FACTOR;
                    
                    // Update membrane potential with controlled arithmetic
                    membrane_potential <= membrane_potential + extended_current - leak_term;
                end
            end
        end
    end

endmodule

   ```
   </details>
   


#### Parameters
- `INPUT_WIDTH` (default: 8): Bit width of the input current
- `POTENTIAL_WIDTH` (default: 16): Bit width of the membrane potential
- `THRESHOLD` (default: 16'h7000): Firing threshold for the neuron
- `LEAK_FACTOR` (default: 4): Power of 2 divisor for membrane potential leakage
- `REFRACTORY_PERIOD` (default: 4): Number of clock cycles to wait after spike

#### Ports
- `clk`: Clock input
- `rst_n`: Active-low reset
- `current_in`: Signed input current [INPUT_WIDTH-1:0]
- `spike_out`: Binary spike output

#### Functionality
1. **Reset Behavior**: 
   - Clears membrane potential
   - Resets refractory counter
   - Sets spike output to 0

2. **Normal Operation**:
   - Integrates input current into membrane potential
   - Applies leakage using right shift operation
   - Generates spike when threshold is reached
   - Implements refractory period after spiking

3. **Key Features**:
   - Fixed-point arithmetic for synthesis
   - Configurable parameters
   - Sign-extended input current
   - Hardware-efficient leak implementation

## Testbench (`tb_claude_lif_neuron_v1.sv`)

### Test Cases

1. **Subthreshold Behavior**
   - Applies small input current (8'h20)
   - Monitors membrane potential buildup
   - Verifies no spurious spikes

2. **Threshold Crossing**
   - Applies large input current (8'h70)
   - Verifies spike generation
   - Validates refractory period

3. **Negative Current**
   - Tests with negative input (-8'h40)
   - Verifies membrane potential decrease
   - Checks sign extension

4. **Alternating Current**
   - Random input current values
   - Tests dynamic response
   - Exercises full operating range

### Monitoring Features
- Internal signal monitoring
- Membrane potential overflow detection
- Waveform dumping (VCD format)
- Detailed console output
- Timeout watchdog

## Usage

### Compilation
```bash
iverilog -g2012 claude_lif_neuron_v1.sv tb_claude_lif_neuron_v1.sv
```

### Simulation
```bash
vvp a.out
```

### Waveform Viewing
```bash
gtkwave lif_neuron_wave.vcd
```

